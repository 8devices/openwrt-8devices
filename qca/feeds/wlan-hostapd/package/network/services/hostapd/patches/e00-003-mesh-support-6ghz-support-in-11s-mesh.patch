From 38823a3ae9fd084ee5822dfb228e109656187e85 Mon Sep 17 00:00:00 2001
From: Pradeep Kumar Chitrapu <pradeepc@codeaurora.org>
Date: Tue, 8 Sep 2020 14:24:37 -0700
Subject: [PATCH] hostapd: Enable 6ghz support in 11s mesh

Enable 6ghz frequencies support in 11s mesh.
Configurations are similar to 5G/2G bands.
example:
	network={
		ssid="pr6gmesh123"
		key_mgmt=SAE
		mode=5
		frequency=6195
		psk="1234567890"
	}

Also, fix assigning secondary channel for only bandwidth greater
than 20 MHz.

Signed-off-by: Pradeep Kumar Chitrapu <pradeepc@codeaurora.org>
---
 src/ap/hostapd.c                |  2 +-
 wpa_supplicant/mesh.c           |  6 ++++
 wpa_supplicant/wpa_supplicant.c | 54 +++++++++++++++++++++------------
 3 files changed, 41 insertions(+), 21 deletions(-)

diff --git a/src/ap/hostapd.c b/src/ap/hostapd.c
index a000e5b08f93..94e02d267d6f 100644
--- a/src/ap/hostapd.c
+++ b/src/ap/hostapd.c
@@ -1710,7 +1710,7 @@ static int setup_interface2(struct hostapd_iface *iface)
 			ch_width = op_class_to_ch_width(iface->conf->op_class);
 			hostapd_set_oper_chwidth(iface->conf, ch_width);
 			if (is_6ghz_op_class(iface->conf->op_class) && !iface->conf->secondary_channel &&
-			    center_idx_to_bw_6ghz(iface->conf->he_oper_centr_freq_seg0_idx))
+			    center_idx_to_bw_6ghz(iface->conf->he_oper_centr_freq_seg0_idx) > 0)
 				iface->conf->secondary_channel = (((iface->conf->channel - 1) / 4 ) % 2) ? -1 : 1 ;
 		}
 
diff --git a/wpa_supplicant/mesh.c b/wpa_supplicant/mesh.c
index c085466b1e71..c1630d09a254 100644
--- a/wpa_supplicant/mesh.c
+++ b/wpa_supplicant/mesh.c
@@ -333,6 +333,12 @@ static int wpa_supplicant_mesh_init(struct wpa_supplicant *wpa_s,
 			   frequency);
 		goto out_free;
 	}
+	ifmsh->freq = frequency;
+
+	/* set 6GHz op_class defaulted to 80MHz */
+	if (is_6ghz_freq(frequency))
+		conf->op_class = 133;
+
 	if (ssid->ht40)
 		conf->secondary_channel = ssid->ht40;
 	if (conf->hw_mode == HOSTAPD_MODE_IEEE80211A && ssid->vht) {
diff --git a/wpa_supplicant/wpa_supplicant.c b/wpa_supplicant/wpa_supplicant.c
index 4f8619c2f881..5cf0a51fce35 100644
--- a/wpa_supplicant/wpa_supplicant.c
+++ b/wpa_supplicant/wpa_supplicant.c
@@ -2348,7 +2348,9 @@ void ibss_mesh_setup_freq(struct wpa_supplicant *wpa_s,
 	struct hostapd_hw_modes *mode = NULL;
 	int ht40plus[] = { 36, 44, 52, 60, 100, 108, 116, 124, 132, 149, 157,
 			   184, 192 };
-	int vht80[] = { 36, 52, 100, 116, 132, 149 };
+	unsigned int bw80[] = { 5180, 5260, 5500, 5580, 5660, 5745, 5955,
+				6035, 6115, 6195, 6275, 6355, 6435, 6515,
+				6595, 6675, 6755, 6835, 6195, 6995 };
 	struct hostapd_channel_data *pri_chan = NULL, *sec_chan = NULL;
 	u8 channel;
 	int i, chan_idx, ht40 = -1, res, obss_scan = 1;
@@ -2356,7 +2358,7 @@ void ibss_mesh_setup_freq(struct wpa_supplicant *wpa_s,
 	struct hostapd_freq_params vht_freq;
 	int chwidth, seg0, seg1;
 	u32 vht_caps = 0;
-	int is_24ghz;
+	int is_24ghz, is_6ghz;
 
 	freq->freq = ssid->frequency;
 
@@ -2408,9 +2410,16 @@ void ibss_mesh_setup_freq(struct wpa_supplicant *wpa_s,
 	if (!mode)
 		return;
 
+	freq->channel = channel;
+
 	is_24ghz = hw_mode == HOSTAPD_MODE_IEEE80211G ||
 		hw_mode == HOSTAPD_MODE_IEEE80211B;
 
+	/* HT/VHT and corresponding overrides are not applicable to 6GHz.
+	 * However, HE is mandatory for 6ghz */
+	if ((is_6ghz = is_6ghz_freq(freq->freq) && (hw_mode == HOSTAPD_MODE_IEEE80211A)) == 1)
+		goto skip_to_6ghz;
+
 #ifdef CONFIG_HT_OVERRIDES
 	if (ssid->disable_ht) {
 		freq->ht_enabled = 0;
@@ -2543,8 +2552,6 @@ skip_ht40:
 	    !(wpa_s->drv_flags & WPA_DRIVER_FLAGS_VHT_IBSS))
 		return;
 
-	vht_freq = *freq;
-
 #ifdef CONFIG_VHT_OVERRIDES
 	if (ssid->disable_vht) {
 		freq->vht_enabled = 0;
@@ -2552,12 +2559,16 @@ skip_ht40:
 	}
 #endif /* CONFIG_VHT_OVERRIDES */
 
+skip_to_6ghz:
+	vht_freq = *freq;
+
+	/* 6GHz does not have vht enabled. So Allow */
 	vht_freq.vht_enabled = vht_supported(mode);
-	if (!vht_freq.vht_enabled)
+	if (!vht_freq.vht_enabled && !is_6ghz)
 		return;
 
 	/* Enable HE with VHT for 5 GHz */
-	freq->he_enabled = mode->he_capab[ieee80211_mode].he_supported;
+	vht_freq.he_enabled = mode->he_capab[ieee80211_mode].he_supported;
 
 #ifdef CONFIG_HE_OVERRIDES
 	if (is_24ghz)
@@ -2565,16 +2576,14 @@ skip_ht40:
 #endif /* CONFIG_HE_OVERRIDES */
 
 	/* setup center_freq1, bandwidth */
-	for (j = 0; j < ARRAY_SIZE(vht80); j++) {
-		if (freq->channel >= vht80[j] &&
-		    freq->channel < vht80[j] + 16)
+	for (j = 0; j < ARRAY_SIZE(bw80); j++)
+		if (freq->freq == bw80[j])
 			break;
-	}
 
-	if (j == ARRAY_SIZE(vht80))
+	if (j == ARRAY_SIZE(bw80))
 		return;
 
-	for (i = vht80[j]; i < vht80[j] + 16; i += 4) {
+	for (i = freq->channel; i < freq->channel + 16; i += 4) {
 		struct hostapd_channel_data *chan;
 
 		chan = hw_get_channel_chan(mode, i, NULL);
@@ -2587,16 +2596,20 @@ skip_ht40:
 	}
 
 	chwidth = CHANWIDTH_80MHZ;
-	seg0 = vht80[j] + 6;
+	seg0 = freq->channel + 6;
 	seg1 = 0;
 
 	if (ssid->max_oper_chwidth == CHANWIDTH_80P80MHZ) {
 		/* setup center_freq2, bandwidth */
-		for (k = 0; k < ARRAY_SIZE(vht80); k++) {
+		for (k = 0; k < ARRAY_SIZE(bw80); k++) {
 			/* Only accept 80 MHz segments separated by a gap */
-			if (j == k || abs(vht80[j] - vht80[k]) == 16)
+			if (j == k || abs(bw80[j] - bw80[k]) == 80)
 				continue;
-			for (i = vht80[k]; i < vht80[k] + 16; i += 4) {
+
+			if (ieee80211_freq_to_chan(bw80[k], &channel) == NUM_HOSTAPD_MODES)
+				return;
+
+			for (i = channel; i < channel + 16; i += 4) {
 				struct hostapd_channel_data *chan;
 
 				chan = hw_get_channel_chan(mode, i, NULL);
@@ -2610,9 +2623,10 @@ skip_ht40:
 
 				/* Found a suitable second segment for 80+80 */
 				chwidth = CHANWIDTH_80P80MHZ;
-				vht_caps |=
-					VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ;
-				seg1 = vht80[k] + 6;
+				if (!is_6ghz)
+					vht_caps |=
+						VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ;
+				seg1 = channel + 6;
 			}
 
 			if (chwidth == CHANWIDTH_80P80MHZ)
@@ -2630,7 +2644,7 @@ skip_ht40:
 		}
 	} else if (ssid->max_oper_chwidth == CHANWIDTH_USE_HT) {
 		chwidth = CHANWIDTH_USE_HT;
-		seg0 = vht80[j] + 2;
+		seg0 = freq->channel + 2;
 #ifdef CONFIG_HT_OVERRIDES
 		if (ssid->disable_ht40)
 			seg0 = 0;
-- 
2.17.1

