From 2dea4f3eea80c9024e2ca291c821dee3f31876b5 Mon Sep 17 00:00:00 2001
From: Abinaya Kalaiselvan <akalaise@codeaurora.org>
Date: Thu, 15 Oct 2020 16:39:56 +0530
Subject: [PATCH] ath11k: Add offchannel scanning support

Advertise NL80211_EXT_FEATURE_SET_SCAN_DWELL to add support for
offchannel scanning.

Usage:
iw wlanX scan trigger freq <freq> duration <dur> ap-force

Ex:
iw wlan0 scan trigger freq 5825 duration 30 ap-force

Sample Output:
iw wlan0 survey dump

Survey data from wlan0
        frequency:                      5825 MHz
        noise:                          -105 dBm
        channel active time:            25 ms

Signed-off-by: Abinaya Kalaiselvan <akalaise@codeaurora.org>
---
 drivers/net/wireless/ath/ath11k/core.h |  2 ++
 drivers/net/wireless/ath/ath11k/mac.c  | 25 ++++++++++++++++++++++---
 drivers/net/wireless/ath/ath11k/wmi.c  |  4 ++++
 drivers/net/wireless/ath/ath11k/wmi.h  |  2 ++
 4 files changed, 30 insertions(+), 3 deletions(-)

Index: backports-20200902_001-5.4.55-931c337125/drivers/net/wireless/ath/ath11k/core.h
===================================================================
--- backports-20200902_001-5.4.55-931c337125.orig/drivers/net/wireless/ath/ath11k/core.h
+++ backports-20200902_001-5.4.55-931c337125/drivers/net/wireless/ath/ath11k/core.h
@@ -33,6 +33,8 @@
 
 #define ATH11K_TX_MGMT_TARGET_MAX_SUPPORT_WMI 64
 
+#define ATH11K_SCAN_CHANNEL_SWITCH_WMI_EVT_OVERHEAD 10 /* msec */
+
 /* Pending management packets threshold for dropping probe responses */
 #define ATH11K_PRB_RSP_DROP_THRESHOLD ((ATH11K_TX_MGMT_TARGET_MAX_SUPPORT_WMI * 3) / 4)
 
Index: backports-20200902_001-5.4.55-931c337125/drivers/net/wireless/ath/ath11k/mac.c
===================================================================
--- backports-20200902_001-5.4.55-931c337125.orig/drivers/net/wireless/ath/ath11k/mac.c
+++ backports-20200902_001-5.4.55-931c337125/drivers/net/wireless/ath/ath11k/mac.c
@@ -3341,6 +3341,7 @@ static int ath11k_mac_op_hw_scan(struct
 	struct scan_req_params *arg;
 	int ret = 0;
 	int i;
+	u32 scan_timeout;
 
 	mutex_lock(&ar->conf_mutex);
 
@@ -3406,6 +3407,21 @@ static int ath11k_mac_op_hw_scan(struct
 			goto exit;
 	}
 
+	if (req->duration) {
+		arg->dwell_time_active = req->duration;
+		arg->dwell_time_passive = req->duration;
+		arg->burst_duration = req->duration;
+
+		scan_timeout = min_t(u32, arg->max_rest_time *
+				    (arg->chan_list.num_chan - 1) + (req->duration +
+				     ATH11K_SCAN_CHANNEL_SWITCH_WMI_EVT_OVERHEAD) *
+				     arg->chan_list.num_chan, arg->max_scan_time +
+				     ATH11K_MAC_SCAN_TIMEOUT_MSECS);
+	} else {
+		/* Add a 200ms margin to account for event/command processing */
+		scan_timeout = arg->max_scan_time + ATH11K_MAC_SCAN_TIMEOUT_MSECS;
+	}
+
 	ret = ath11k_start_scan(ar, arg);
 	if (ret) {
 		ath11k_warn(ar->ab, "failed to start hw scan: %d\n", ret);
@@ -3414,10 +3430,8 @@ static int ath11k_mac_op_hw_scan(struct
 		spin_unlock_bh(&ar->data_lock);
 	}
 
-	/* Add a 200ms margin to account for event/command processing */
 	ieee80211_queue_delayed_work(ar->hw, &ar->scan.timeout,
-				     msecs_to_jiffies(arg->max_scan_time +
-						      ATH11K_MAC_SCAN_TIMEOUT_MSECS));
+				     msecs_to_jiffies(scan_timeout));
 
 exit:
 	if (arg) {
@@ -8016,6 +8030,11 @@ static int __ath11k_mac_register(struct
 
 	wiphy_ext_feature_set(ar->hw->wiphy, NL80211_EXT_FEATURE_ACK_SIGNAL_SUPPORT);
 
+	if (test_bit(WMI_TLV_SERVICE_PASSIVE_SCAN_START_TIME_ENHANCE,
+                     ar->ab->wmi_ab.svc_map))
+		 wiphy_ext_feature_set(ar->hw->wiphy,
+				       NL80211_EXT_FEATURE_SET_SCAN_DWELL);
+
 	ar->hw->queues = ATH11K_HW_MAX_QUEUES;
 	ar->hw->wiphy->tx_queue_len = ATH11K_QUEUE_LEN;
 	ar->hw->offchannel_tx_hw_queue = ATH11K_HW_MAX_QUEUES - 1;
Index: backports-20200902_001-5.4.55-931c337125/drivers/net/wireless/ath/ath11k/wmi.c
===================================================================
--- backports-20200902_001-5.4.55-931c337125.orig/drivers/net/wireless/ath/ath11k/wmi.c
+++ backports-20200902_001-5.4.55-931c337125/drivers/net/wireless/ath/ath11k/wmi.c
@@ -2219,6 +2219,9 @@ void ath11k_wmi_start_scan_init(struct a
 				  WMI_SCAN_EVENT_FOREIGN_CHAN |
 				  WMI_SCAN_EVENT_DEQUEUED;
 	arg->scan_flags |= WMI_SCAN_CHAN_STAT_EVENT;
+	if (test_bit(WMI_TLV_SERVICE_PASSIVE_SCAN_START_TIME_ENHANCE,
+	             ar->ab->wmi_ab.svc_map))
+		arg->scan_ctrl_flags_ext |= WMI_SCAN_FLAG_EXT_PASSIVE_SCAN_START_TIME_ENHANCE;
 	arg->num_bssid = 1;
 }
 
@@ -2392,6 +2395,7 @@ int ath11k_wmi_send_scan_start_cmd(struc
 	cmd->num_ssids = params->num_ssids;
 	cmd->ie_len = params->extraie.len;
 	cmd->n_probes = params->n_probes;
+	cmd->scan_ctrl_flags_ext = params->scan_ctrl_flags_ext;
 
 	ptr += sizeof(*cmd);
 
Index: backports-20200902_001-5.4.55-931c337125/drivers/net/wireless/ath/ath11k/wmi.h
===================================================================
--- backports-20200902_001-5.4.55-931c337125.orig/drivers/net/wireless/ath/ath11k/wmi.h
+++ backports-20200902_001-5.4.55-931c337125/drivers/net/wireless/ath/ath11k/wmi.h
@@ -2137,6 +2137,17 @@ enum wmi_tlv_service {
 	WMI_TLV_SERVICE_TPC_STATS_EVENT = 251,
 	WMI_TLV_SERVICE_NO_INTERBAND_MCC_SUPPORT = 252,
 	WMI_TLV_SERVICE_MBSS_PARAM_IN_VDEV_START_SUPPORT = 253,
+	WMI_TLV_SERVICE_CONFIGURE_ROAM_TRIGGER_PARAM_SUPPORT = 254,
+	WMI_TLV_SERVICE_CFR_TA_RA_AS_FP_SUPPORT = 255,
+
+	WMI_TLV_SERVICE_CFR_CAPTURE_COUNT_SUPPORT = 256,
+	WMI_TLV_SERVICE_OCV_SUPPORT = 257,
+	WMI_TLV_SERVICE_LL_STATS_PER_CHAN_RX_TX_TIME_SUPPORT = 258,
+	WMI_TLV_SERVICE_THERMAL_MULTI_CLIENT_SUPPORT = 259,
+	WMI_TLV_SERVICE_NAN_SEND_NAN_ENABLE_RESPONSE_TO_HOST = 260,
+	WMI_TLV_SERVICE_UNIFIED_LL_GET_STA_CMD_SUPPORT = 261,
+	WMI_TLV_SERVICE_FSE_CMEM_ALLOC_SUPPORT = 262,
+	WMI_TLV_SERVICE_PASSIVE_SCAN_START_TIME_ENHANCE = 263,
 
 	WMI_MAX_EXT_SERVICE
 };
@@ -3317,6 +3328,7 @@ struct  wmi_start_scan_cmd {
 
 #define WMI_SCAN_DWELL_MODE_MASK 0x00E00000
 #define WMI_SCAN_DWELL_MODE_SHIFT        21
+#define WMI_SCAN_FLAG_EXT_PASSIVE_SCAN_START_TIME_ENHANCE   0x00000800
 
 enum {
 	WMI_SCAN_DWELL_MODE_DEFAULT      = 0,
@@ -3380,6 +3392,7 @@ struct scan_req_params {
 		};
 		u32 scan_events;
 	};
+	u32 scan_ctrl_flags_ext;
 	u32 dwell_time_active;
 	u32 dwell_time_active_2g;
 	u32 dwell_time_passive;
