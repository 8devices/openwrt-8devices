From 32c27c4c09bc696894c26c10a7f58916192893b5 Mon Sep 17 00:00:00 2001
From: Anilkumar Kolli <akolli@codeaurora.org>
Date: Tue, 24 Mar 2020 11:28:57 +0530
Subject: [PATCH 1171/1179] ath11k: use static window for register access

qcn9000 uses static window mapping for
CE and UMAC register read write.

Signed-off-by: Anilkumar Kolli <akolli@codeaurora.org>
---
 drivers/net/wireless/ath/ath11k/core.h |  2 ++
 drivers/net/wireless/ath/ath11k/hal.h  |  3 ++
 drivers/net/wireless/ath/ath11k/pci.c  | 54 ++++++++++++++++++++++++++++++++--
 3 files changed, 56 insertions(+), 3 deletions(-)

--- a/drivers/net/wireless/ath/ath11k/core.h
+++ b/drivers/net/wireless/ath/ath11k/core.h
@@ -810,6 +810,8 @@ struct ath11k_base {
 	bool mhi_support;
 	bool fixed_mem_region;
 	bool use_register_windowing;
+	bool static_window_map;
+
 	/* must be last */
 	u8 drv_priv[0] __aligned(sizeof(void *));
 };
--- a/drivers/net/wireless/ath/ath11k/hal.h
+++ b/drivers/net/wireless/ath/ath11k/hal.h
@@ -35,6 +35,7 @@ struct ath11k_base;
 #define SHADOW_NUM_REGISTERS				36
 
 /* WCSS Relative address */
+#define HAL_SEQ_WCSS_UMAC_OFFSET		0x00a00000
 #define HAL_SEQ_WCSS_UMAC_REO_REG		0x00a38000
 #define HAL_SEQ_WCSS_UMAC_TCL_REG		0x00a44000
 #define HAL_SEQ_WCSS_UMAC_CE0_SRC_REG		0x00a00000
@@ -43,6 +44,8 @@ struct ath11k_base;
 #define HAL_SEQ_WCSS_UMAC_CE1_DST_REG		0x00a03000
 #define HAL_SEQ_WCSS_UMAC_WBM_REG		0x00a34000
 
+#define HAL_CE_WFSS_CE_REG_BASE			0x01b80000
+
 /* SW2TCL(x) R0 ring configuration address */
 #define HAL_TCL1_RING_CMN_CTRL_REG		0x00000014
 #define HAL_TCL1_RING_DSCP_TID_MAP		0x0000002c
--- a/drivers/net/wireless/ath/ath11k/pci.c
+++ b/drivers/net/wireless/ath/ath11k/pci.c
@@ -261,15 +261,53 @@ static inline struct ath11k_pci *ath11k_
 	return (struct ath11k_pci *)ab->drv_priv;
 }
 
+static inline void ath11k_pci_register_window(struct ath11k_pci *ar_pci)
+{
+	u32 umac_window = (HAL_SEQ_WCSS_UMAC_OFFSET >> WINDOW_SHIFT) & WINDOW_VALUE_MASK;
+	u32 ce_window = (HAL_CE_WFSS_CE_REG_BASE >> WINDOW_SHIFT) & WINDOW_VALUE_MASK;
+	u32 window;
+
+	window = (umac_window << 12) | (ce_window << 6);
+
+	iowrite32(WINDOW_ENABLE_BIT | window,
+		  ar_pci->mem + WINDOW_REG_ADDRESS);
+}
+
+static inline u32 ath11k_pci_get_window_start(struct ath11k_base *ab,
+                                              u32 offset)
+{
+        u32 window_start;
+
+        if ((offset ^ HAL_SEQ_WCSS_UMAC_OFFSET) < WINDOW_RANGE_MASK)
+                window_start = 3 * WINDOW_START;
+        else if ((offset ^ HAL_CE_WFSS_CE_REG_BASE) < WINDOW_RANGE_MASK)
+                window_start = 2 * WINDOW_START;
+        else
+                window_start = WINDOW_START;
+
+        return window_start;
+}
+
 static void ath11k_pci_write32(struct ath11k_base *ab, u32 offset, u32 value)
 {
 	struct ath11k_pci *ar_pci = ath11k_pci_priv(ab);
+        u32 window_start;
 
-	if (ab->use_register_windowing) {
-		spin_lock_bh(&ar_pci->window_lock);
-		ath11k_pci_select_window(ar_pci, offset);
-		iowrite32(value, ar_pci->mem + WINDOW_START + (offset & WINDOW_RANGE_MASK));
-		spin_unlock_bh(&ar_pci->window_lock);
+        if ((ab->use_register_windowing || ab->static_window_map) &&
+	    offset >= MAX_UNWINDOWED_ADDRESS) {
+		if (ab->static_window_map)
+                	window_start = ath11k_pci_get_window_start(ab, offset);
+		else
+			window_start = WINDOW_START;
+
+		if (window_start == WINDOW_START) {
+			spin_lock_bh(&ar_pci->window_lock);
+			ath11k_pci_select_window(ar_pci, offset);
+			iowrite32(value, ar_pci->mem +  window_start + (offset & WINDOW_RANGE_MASK));
+			spin_unlock_bh(&ar_pci->window_lock);
+		} else {
+			iowrite32(value, ar_pci->mem +  window_start + (offset & WINDOW_RANGE_MASK));
+		}
 	} else {
 		iowrite32(value, ar_pci->mem  + offset);
 	}
@@ -278,13 +316,23 @@ static void ath11k_pci_write32(struct at
 static u32 ath11k_pci_read32(struct ath11k_base *ab, u32 offset)
 {
 	struct ath11k_pci *ar_pci = ath11k_pci_priv(ab);
-	u32 val;
+        u32 val, window_start;
 
-	if (ab->use_register_windowing) {
-		spin_lock_bh(&ar_pci->window_lock);
-		ath11k_pci_select_window(ar_pci, offset);
-		val = ioread32(ar_pci->mem + WINDOW_START + (offset & WINDOW_RANGE_MASK));
-		spin_unlock_bh(&ar_pci->window_lock);
+        if ((ab->use_register_windowing || ab->static_window_map ) &&
+	    offset >= MAX_UNWINDOWED_ADDRESS) {
+		if (ab->static_window_map)
+                	window_start = ath11k_pci_get_window_start(ab, offset);
+		else
+			window_start = WINDOW_START;
+
+		if (window_start == WINDOW_START) {
+			spin_lock_bh(&ar_pci->window_lock);
+			ath11k_pci_select_window(ar_pci, offset);
+			val = ioread32(ar_pci->mem + window_start + (offset & WINDOW_RANGE_MASK));
+			spin_unlock_bh(&ar_pci->window_lock);
+		} else {
+			val = ioread32(ar_pci->mem + window_start + (offset & WINDOW_RANGE_MASK));
+		}
 	} else {
 		val = ioread32(ar_pci->mem + offset);
 	}
@@ -677,6 +725,9 @@ static int ath11k_pci_power_up(struct at
 	if (ret)
 		ath11k_err(ab, "failed to power on  mhi: %d\n", ret);
 
+	if (ab->static_window_map)
+		ath11k_pci_register_window(ar_pci);
+
 	return ret;
 }
 
@@ -822,6 +873,7 @@ static int ath11k_pci_probe(struct pci_d
 	ab->use_register_windowing = true;
 	if (ab->hw_rev == ATH11K_HW_QCN90XX) {
 		ab->fixed_mem_region = true;
+		ab->static_window_map = true;
 	} else {
 		ab->fixed_mem_region = false;
 	}
--- a/drivers/net/wireless/ath/ath11k/hal.c
+++ b/drivers/net/wireless/ath/ath11k/hal.c
@@ -1083,9 +1083,8 @@ int ath11k_hal_srng_setup(struct ath11k_
 						   lmac_idx);
 			srng->flags |= HAL_SRNG_FLAGS_LMAC_RING;
 		} else {
-			srng->u.dst_ring.tp_addr =
-				(u32 *)((unsigned long)ab->mem + reg_base +
-					(HAL_REO1_RING_TP - HAL_REO1_RING_HP));
+			srng->u.dst_ring.tp_addr = (u32 *)((unsigned long)ab->mem + reg_base +
+							   (HAL_REO1_RING_TP - HAL_REO1_RING_HP));
 		}
 	}
 
