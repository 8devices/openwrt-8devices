--- a/drivers/ata/libata-core.c
+++ b/drivers/ata/libata-core.c
@@ -1581,6 +1581,14 @@ unsigned ata_exec_internal_sg(struct ata
 		return AC_ERR_SYSTEM;
 	}
 
+	if (ap->ops->acquire_hw && !ap->ops->acquire_hw(ap, 0, 0)) {
+		spin_unlock_irqrestore(ap->lock, flags);
+		if (!ap->ops->acquire_hw(ap, 1, (2*HZ))) {
+			return AC_ERR_TIMEOUT;
+		}
+		spin_lock_irqsave(ap->lock, flags);
+	}
+
 	/* initialize internal qc */
 
 	/* XXX: Tag 0 is used for drivers with legacy EH as some
@@ -4796,6 +4804,9 @@ static struct ata_queued_cmd *ata_qc_new
 	if (unlikely(ap->pflags & ATA_PFLAG_FROZEN))
 		return NULL;
 
+	if (ap->ops->qc_new && ap->ops->qc_new(ap))
+		return NULL;
+
 	for (i = 0, tag = ap->last_tag + 1; i < max_queue; i++, tag++) {
 		if (ap->flags & ATA_FLAG_LOWTAG)
 			tag = i;
@@ -4868,6 +4879,8 @@ void ata_qc_free(struct ata_queued_cmd *
 	if (likely(ata_tag_valid(tag))) {
 		qc->tag = ATA_TAG_POISON;
 		clear_bit(tag, &ap->qc_allocated);
+		if (ap->ops->qc_free)
+			ap->ops->qc_free(qc);
 	}
 }
 
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -903,6 +903,8 @@ struct ata_port_operations {
 	void (*qc_prep)(struct ata_queued_cmd *qc);
 	unsigned int (*qc_issue)(struct ata_queued_cmd *qc);
 	bool (*qc_fill_rtf)(struct ata_queued_cmd *qc);
+	int (*qc_new)(struct ata_port *ap);
+	void (*qc_free)(struct ata_queued_cmd *qc);
 
 	/*
 	 * Configuration and exception handling
@@ -993,6 +995,9 @@ struct ata_port_operations {
 	void (*phy_reset)(struct ata_port *ap);
 	void (*eng_timeout)(struct ata_port *ap);
 
+	int (*acquire_hw)(struct ata_port *ap, int may_sleep,
+			  int timeout_jiffies);
+
 	/*
 	 * ->inherits must be the last field and all the preceding
 	 * fields must be pointers.
